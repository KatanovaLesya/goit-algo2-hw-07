# ДЗ7: Алгоритми керування кешем

## Опис

Цей проєкт демонструє використання кешування для оптимізації обчислень. Розглянуто два основні завдання:

## Завдання 1. LRU-кеш для оптимізації доступу до масиву

### Реалізовано:

- `range_sum_no_cache(array, L, R)` — сумування без кешу
- `update_no_cache(array, index, value)` — оновлення без кешу
- `range_sum_with_cache(array, L, R)` — сумування з LRU-кешем (`@lru_cache`)
- `update_with_cache(array, index, value)` — оновлення з очищенням кешу

### Тестування

- Створено масив із 100_000 випадкових чисел
- Згенеровано 50_000 випадкових запитів (`Range` або `Update`)
- Виміряно час виконання з кешем і без кешу

### Приклад виводу

Час виконання без кешування: 15.91 секунд
Час виконання з LRU-кешем: 14.50 секунд

## Завдання 2. Порівняння LRU Cache vs Splay Tree (числа Фібоначчі)

### Реалізовано

- `fibonacci_lru(n)` — рекурсивна функція з `@lru_cache`
- `fibonacci_splay(n, tree)` — обчислення з використанням Splay Tree

## Як запустити

```bash
python3 main.py                
python3 fibonacci_compare.py  
```

### Тести

Обчислюються числа Фібоначчі для `n` від 0 до 950 (крок 50)
Для кожного `n` — заміри часу з `timeit.repeat(...)`
Побудовано графік порівняння часу
